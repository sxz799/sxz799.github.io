---
title: 青丝白雪
copyright: true
date: 2019-07-11 15:02:04
tags:
- 学习
categories:
- 学习
comments:
password:
---

## 6-1 体育俱乐部I（构造函数） 一个俱乐部需要保存它的简要信息
一个俱乐部需要保存它的简要信息，包括四项：名称（字符串），成立年份（整数），教练姓名（字符串）和教练胜率（0－100之间的整数）。用键盘输入这些信息后，把它们分两行输出：第一行输出名称和成立年份，第二行输出教练姓名和胜率。
```
Club::Club(string n1, int y, string n2, int wr):c(n2,wr)
{
    name=n1;
    year=y;
}

void Club::show()
{
    cout<<name<<" "<<year<<endl;
    c.show();
}
void Coach::show()
{
    cout<<name<<" "<<winRate<<"%"<<endl;
}
```

## 6-2 学生成绩的快速录入（构造函数）现在需要录入一批学生的成绩（学号，成绩）
现在需要录入一批学生的成绩（学号，成绩）。其中学号是正整数，并且录入时，后录入学生的学号会比前面的学号大；成绩分两等，通过(Pass,录入时用1代表),不通过(Fail,录入时用0代表）。
由于很多学号都是相邻的，并且学号相邻的学生成绩常常相同。所以在录入时，适当地加了速。如果当前学生的学号比前面的学号大1，且成绩与前面的成绩相同，则只输入0即可。
```
class Student
{
public:
    Student(int _no ,int _score);
    Student(Student &s);
    void display();
    int static count;
private:
    int m_no;
    int m_score;
};

Student::Student(int _no ,int _score)
{
    m_no = _no;
    m_score = _score;
    count++;
}
Student::Student(Student &s)
{
    m_no = s.m_no+1;
    m_score = s.m_score;
    count++;
}
void Student::display()
{
    cout<<this->m_no<<" ";
    if(this->m_score == 1)
        cout<<"Pass"<<endl;
    else
        cout<<"Fail"<<endl;
}
int  Student::count = 0;
```

## 6-3 学生平均分计算 定义一学生类，已有若干个学生数据，包
定义一学生类，已有若干个学生数据，包括学号、姓名、成绩，要求输出这些学生数据并计算平均分。
```
class Stud
{
public:
	Stud(int no,string name,int score);
	void disp();
	int static avg();
private:
	int ino;
	string strname;
	int iscore;
	static int sum;
	static int num;
};

Stud::Stud(int no,string name,int score):ino(no),strname(name),iscore(score)
{
	num++;
	sum=sum+score;
}
void Stud::disp()
{
	cout<<ino<<","<<strname<<","<<iscore<<endl;
}
int  Stud::avg()
{
	return (sum/num);
}
```

## 6-4 学生成绩计算（友元函数） 现有学生类Student，包含私有数据成员：
现有学生类Student，包含私有数据成员：学号(sno，string类型)、姓名(sname，string类型)及C++考试成绩(cpp_score，double类型)。 
要求：用类Student建立学生对象数组，不超过100名学生。输入学生的学号、姓名及C++考试成绩，以输入0结束，计算输出所有学生的C++平均成绩。其中，平均成绩用友元函数void average(Student *ps, int count)计算。 
注意：（1）以上类名和友元函数的形式，均须按照题目要求，不得修改；（2）结果保留1位小数.
```
void average(Student *ps, int count)
{
	double temp=0;
	for(int i=0;i<count;i++)
	{
		temp+=ps->cpp_score;
		ps++;
	}
	cout<<fixed<<setprecision(1);
	cout<<(temp/(count))<<endl;
}
```

## 6-5 汽车收费
现在要开发一个系统，管理对多种汽车的收费工作。 给出下面的一个基类框架
```
class Car :public Vehicle
{
public:
    Car(string no, int guest, int weight):Vehicle(no)
    {
        gu=guest;
        wei=weight;
    }
    int fee()
    {
        return gu*8+wei*2;
    }
private:
    int gu;
    int wei;
};
class Truck :public Vehicle
{
public:
    Truck(string no, int weight):Vehicle(no)
    {
        wei=weight;
    }
    int fee()
    {
        return wei*5;
    }
private:
    int wei;
};
class Bus :public Vehicle
{
public:
    Bus(string no, int guest):Vehicle(no)
    {
        gu=guest;
    }
    int fee()
    {
        return gu*3;
    }
private:
    int gu;
};

```

## 6-6 狗的继承 完成两个类，一个类Animal，表示动物类，有一个成员表示年龄。
完成两个类，一个类Animal，表示动物类，有一个成员表示年龄。一个类Dog，继承自Animal，有一个新的数据成员表示颜色，合理设计这两个类，使得测试程序可以运行并得到正确的结果。
```
#include<iostream>
#include <string>
using namespace std;
class Animal
{
public:
    Animal(int _age);
    int getAge();
public:
    int age;  
};
class Dog :public Animal
{
public:
    Dog(int _age,string col);
    void showInfor();
private:
    string color;
};
Animal::Animal(int _age)
{
    age=_age; 
}
int Animal::getAge()
{
    return age;
}
Dog::Dog(int _age,string col):Animal(_age),color(col)
{

}
void Dog::showInfor()
{
    cout<<"age:"<<age<<endl;
    cout<<"color:"<<color<<endl;
}
```

## 6-7 学生成绩的输入和输出（运算符重载 现在需要输入一组学生的姓名和成绩
现在需要输入一组学生的姓名和成绩，然后输出这些学生的姓名和等级
```
class Student{
    private:
        int num=0;
        string name;
        int score;
    public:
        friend ostream& operator<<(ostream& os,Student& st){
            if(st.score>=60){
            os<<st.num<<". "<<st.name<<" "<<"PASS";
        }else{
            os<<st.num<<". "<<st.name<<" "<<"FAIL";
        }
        return os;
        };

        friend istream& operator>>(istream& is,Student& st){
            st.num+=1;
            is>>st.name>>st.score;
            return is;
        };
};
```

## 6-8单目运算符重载（时钟类）本题已给出时钟类及其成员函数实现，要求补充
本题已给出时钟类及其成员函数实现，要求补充完整运算符++重载函数（前置和后置），使之能够实现时钟对象自增1秒。
```
Clock operator++(Clock& op){
	op.Second++;
	if(op.Second==60){
		op.Second=0;
		op.Minute++;
    }
	if(op.Minute==60){
		op.Minute=0;
		op.Hour++;
    }
	if(op.Hour==24){
		op.Hour=0;
	}
	return op;
}
Clock operator++(Clock& op,int){
    Clock t=op;
	op.Second++;
	if(op.Second==60){
		op.Second=0;
		op.Minute++;
    }
	if(op.Minute==60){
		op.Minute=0;
		op.Hour++;
    }
	if(op.Hour==24){
		op.Hour=0;
	}
	return t;
}

```

## 6-9 有序数组（类模板） (10 分) 实现一个类模板，它可以接受一组数据，能对数据排序，也能输出数组的内容
实现一个类模板，它可以接受一组数据，能对数据排序，也能输出数组的内容。
每行输入的第一个数字为0，1，2或3:为0时表示输入结束； 为1时表示将输入整数，为2时表示将输入有一位小数的浮点数，为3时表示输入字符。
如果第一个数字非0，则接下来将输入一个正整数，表示即将输入的数据的数量。
从每行第三个输入开始，依次输入指定类型的数据。
```
template<class T>
class MyArray{
	private:
		int size;
		T *data;
	public:
		MyArray(int s);
		~MyArray();
		bool check();
		void sort();
		void display();

};

template<class T>
MyArray<T>::MyArray(int s){
		size=s;
		data=new T[size];
		for(int i=0;i<size;i++)
		cin>>data[i];
		}


template<class T>
void MyArray<T>::sort(){
		for(int i=0;i<size-1;i++){
			for(int j=0;j<size-i-1;j++){
				if(data[j]>data[j+1]){
					T temp=data[j];
					data[j]=data[j+1];
					data[j+1]=temp;
				}
			}
		}
		}
		
template<class T>
void MyArray<T>::display(){
		for(int i=0;i<size;i++){
			cout<<data[i];
			if(i<size-1)
				cout<<" ";
			}
			cout<<endl;
		};

```

## 6-10 数组排序输出（函数模板） (10 分) 对于输入的每一批数，按从小到大排序后输出
对于输入的每一批数，按从小到大排序后输出
一行输入为一批数，第一个输入为数据类型（1表示整数，2表示字符型数，3表示有一位小数的浮点数，4表示字符串，0表示输入结束），第二个输入为该批数的数量size`0<size<=10）“"`，接下来为size个指定类型的数据

```
template<class T>
void sort(T* a,int size){
	for(int i=0;i<size;i++)
	cin>>a[i];
	
	for(int i=0;i<size-1;i++)
		for(int j=0;j<size-i-1;j++){
			if(a[j]>a[j+1]){
			T temp=a[j+1];
			a[j+1]=a[j];
			a[j]=temp;
		}
		}
}

```

## 7-1 该日是该年的第几天 (10 分 定义一个日期类Date，内有数据成员年、月、日，另有成员函数：构造函数用于初始化数据成员，输出，闰年的判断
定义一个日期类Date，内有数据成员年、月、日，另有成员函数：构造函数用于初始化数据成员，输出，闰年的判断。 编写主函数：创建日期对象，计算并输出该日是该年的第几天。 输入格式： 测试输入包含若干测试用例，每个测试用例占一行。当读入0 0 0时输入结束，相应的结果不要输出。
```

#include <iostream>
using namespace std;
class Date  //声明日期类
{
public:
    Date(int y,int m,int d);
    bool isLeap();//判断是否是闰年的函数
    int NumberofDate();//计算多少天的函数
private:
    int year;
    int month;
    int day;    
};
 
Date::Date(int y,int m,int d)
{
    year=y;
    month=m;
    day=d;
}
bool Date::isLeap()
{
    if((year%4==0&&year%100!=0)||(year%400==0))
    {
        return true;
    }
    else
    {
        return false;
    }
}
 
int Date::NumberofDate()
{
    int a[12]={31,28,31,30,31,30,31,31,30,31,30,31};
    if(isLeap())
    {
        a[1]=29;
    }
    int number=0;
    for(int i=0;i<month-1;i++)
    {
        number+=a[i];
    }
    number+=day;
	return number;
}   
 
int main()
{
	int y,m,d;
	cin>>y>>m>>d;
	while(y!=0 && m!=0 && d!=0)
	{
	Date *date= new Date(y,m,d);
	cout<<date->NumberofDate()<<endl;
	delete date;
	cin>>y>>m>>d;
	}

	return 0;
}

```

## 7-2立方体类的实现
立方体类Box的实现，完成计算体积、计算表面积、输出结果等功能。其中给定的主函数为：
```
#include <iostream>
using namespace std;
class Box
{
public:
	void seta(float _ab)
	{
		ab=_ab;
	}
	float getvolume()
	{
		volume = ab*ab*ab;
		return 0;
	}
	float getarea()
	{
		area = 6*ab*ab;
		return 0;
	}
	void disp()
	{
		cout<<volume<<" "<<area<<endl;
	}
private:
	float ab;
	float volume;
	float area;
};
int  main( ){
    float ab;
    cin>>ab;
    Box  obj;
    obj.seta( ab );
    obj.getvolume( );
    obj.getarea( );
    obj.disp( );
    return 0;
}
```
## 7-3 复数类的操作 声明一复数类Complex（类私有数据成员为double型的real和image）
声明一复数类Complex（类私有数据成员为double型的real和image）
定义构造函数，用于指定复数的实部与虚部
```
#include <iostream>
using namespace std;
class Comlpex
{
public:
	Comlpex(){}
	Comlpex(double _real,double _image):real(_real),image(_image){}
	Comlpex getUcomplex()
	{
		real= -real;
		image= -image;
		return Comlpex(real,image);
	}
	void Print()
	{
		cout<<"("<<real<<", "<<image<<")"<<endl;
	}
	friend Comlpex getSum(Comlpex &x,Comlpex &y);

private:
	double real;
	double image;
	
};
	Comlpex getSum(Comlpex &x,Comlpex &y)
	{
		return Comlpex(y.real+x.real,y.image+x.image);
	}

int  main( ){
	double a,b,c,d;
	cin>>a>>b;
	Comlpex c1(a,b);
	cin>>c>>d;
	Comlpex c2(c,d);
	
	
	getSum(c1,c2).Print();
	c2.getUcomplex();
	getSum(c1,c2).Print();
	c2.getUcomplex();
	c2.Print();
}
```

## 7-4 期刊收费 邮局提供两种期刊的订阅：
邮局提供两种期刊的订阅：杂志和报纸。 给出下面基类的框架：
```
#include<iostream>
#include<iomanip>
using namespace std;
class Periodical
{
  protected:
    string title; //名称
    float price;
    int amount;
  public:
    Periodical(string t,float p,int a):title(t),price(p),amount(a){
    }
    virtual void display()=0;//打印收费
};
class Magazine:public Periodical
{
  public:
    Magazine(string t,float p,int a):Periodical(t,p,a){
    }
    void display();
};
void Magazine::display()
{
  cout<<title<<" "<<setiosflags(ios::fixed)<<setprecision(1)<<price*amount<<endl;
}
class Newspaper:public Periodical
{
  int week;
  public:
    Newspaper(string t,float p,int a,int w):Periodical(t,p,a){week=w;
    }
    void display();
};
void Newspaper::display()
{
  cout<<title<<" "<<setiosflags(ios::fixed)<<setprecision(1)<<price*amount*week<<endl;
 } 
int main()
{
  Periodical *pp[10];
  int type,amount,week,i=0;
  string name;
  float price;
  cin>>type;
  while(type!=0)
  {
    cin>>name>>price>>amount;
    if(type==1)
    {
      pp[i]=new Magazine(name,price,amount);
      pp[i++]->display();
    }
    else
    {
      cin>>week;
      pp[i]=new Newspaper(name,price,amount,week);
      pp[i++]->display();
    }
    cin>>type;
  }
  return 0;
}
```

## 7-5 饮料的价格 一个茶吧提供三类饮料：茶、咖啡和牛奶。
一个茶吧提供三类饮料：茶、咖啡和牛奶。其中本地茶要另加50%的服务费，其它茶要加20%的服务费；现磨咖啡要加100%的服务费，其它咖啡加20%的服务费；牛奶不加服务费，服务费精确到小数点一位。
```
#include<iostream>
#include<iomanip>
using namespace std;

class Drink { 
    protected:
        int NO; //编号
        int amount; //数量
        float price; //单价
    public:
        Drink(int NO,int amount,float price):NO(NO),amount(amount),price(price){};
        virtual void display()=0;//输出费用
};

class Tea :public Drink{
    private:
        int area;
        float tip;
    public:
        Tea(int NO,int amount,float price,int area):Drink(NO,amount,price),area(area){
            if(area==1){
                tip=(price+price*0.5)*amount;
            }else{
                tip=(price+price*0.2)*amount;
            }
        };
        void display(){
            cout<<NO;
            cout<<" "<<fixed<<setprecision(1)<<tip<<endl;
        };
};
class Coffee :public Drink{
    private:
        int operate;
        float tip;
    public: 
        Coffee(int NO,int amount,float price,int operate):Drink(NO,amount,price),operate(operate){
            if(operate==1){
                tip=(price+price)*amount;
            }else{
                tip=(price+price*0.2)*amount;
            }
        };
        void display(){
            cout<<NO;
            cout<<" "<<fixed<<setprecision(1)<<tip<<endl;
        };
};
class Milk :public Drink{   
    private:
        float tip;
    public: 
        Milk(int NO,int amount,float price):Drink(NO,amount,price){
            tip=price*amount;
        };
        void display(){
            cout<<NO;
            cout<<" "<<fixed<<setprecision(1)<<tip<<endl;
        };
};

int main(){
    Drink *pd[10];
    int count=0;
    int ty;
    int no,am,ar,op;
    float pr;
    cin>>ty;
    
    while(ty>0){
        switch(ty){
            case 1: cin>>no>>am>>pr>>ar; pd[count++]=new Tea(no,am,pr,ar); pd[count-1]->display();break;
            case 2: cin>>no>>am>>pr>>op; pd[count++]=new Coffee(no,am,pr,op); pd[count-1]->display();break;
            case 3: cin>>no>>am>>pr; pd[count++]=new Milk(no,am,pr);    pd[count-1]->display();break;
                }
                cin>>ty;
                }
}

```

## 7-6 运算符重载  请定义一个分数类，拥有两个整数的私有数据成员，分别表示分子和分母
请定义一个分数类，拥有两个整数的私有数据成员，分别表示分子和分母（分母永远为正数，符号通过分子表示）。 重载运算符加号"+"，实现两个分数的相加，所得结果必须是最简分数。
```
#include<iostream>
using namespace std;

int gcd(int a,int b){
    return b?gcd(b,a%b):a;
}

class fs{
    public:
        int z,m;
        fs(int a,int b){
            z=a;
            m=b;
        }
        void add(fs A){
            z=z*A.m+A.z*m;
            m*=A.m;
        }
        void show(){
            int x=gcd(z,m);
            if(x==m){
                cout<<z/x;
            }
            else{
                cout<<z/x<<" "<<m/x;
            }
        }
};

int main(){
    int a,b;
    cin>>a>>b;
    fs A(a,b);
    cin>>a>>b;
    fs C(a,b);
    A.add(C);
    A.show();
} 
```
## 7-7 计算时间相减 定义一个时间类，小时和分钟是其两个私有成员数据。
定义一个时间类，小时和分钟是其两个私有成员数据。输入一个起始时间和一个结束时间(起始时间早于结束时间)，通过运算符重载-（减号），计算这两个时间相隔多少分钟。说明：这两个时间在同一天之内，且采用24小时计时分式，即从00:00-23:59。
```
#include<iostream>
#include<stdlib.h>
using namespace std;
class Time
{
      int m;
      int s;
      public:
             void set(int m,int s){this->m=m;this->s=s;}
             int operator -(Time&);
};
int Time::operator -(Time& p)
{
    int s1,s2;
    s1=m*60+s;
    s2=p.m*60+p.s;
    return s1-s2>0?s1-s2:s2-s1;
}
int main()
{
    Time t1,t2;
    int a,b,c,d;
    cin>>a>>b>>c>>d;
    while(a!=0||b!=0||c!=0||d!=0)
    {
      t1.set(a,b);
      t2.set(c,d);
      cout<<t1-t2<<endl;
      cin>>a>>b>>c>>d;
    }
    system("pause");
    return 0;
}
```
## 7-8 数据的间距问题 复数类Complex有两个数据成员：a和b, 分别代表复数的实部和虚部
复数类Complex有两个数据成员：a和b, 分别代表复数的实部和虚部，并有若干构造函数和一个重载-（减号，用于计算两个复数的距离）的成员函数。 要求设计一个函数模板
```
#include<iostream>
#include<cmath>
using namespace std;

class Complex
{
private:
    double a, b;
public:
    Complex()
    {
        a = 0, b = 0;
    }
    Complex(double A, double B)
    {
        a = A, b = B;
    }
    void set(double A, double B)
    {
        a = A, b = B;
    }
    void display()
    {
        cout << a << " " << b << endl;
    }
    friend double operator - (Complex C1, Complex C2);
};

double operator -(Complex C1, Complex C2)
{
    return sqrt(pow(C1.a - C2.a, 2.0) + pow(C1.b - C2.b, 2.0));
}

template<class T>
double dist(T a, T b)
{
    return abs(a - b);
}

int main()
{
    int flag;

    while(cin >> flag, flag != 0)
    {
        if(flag == 1)
        {
            int a, b;
            cin >> a >> b;
            cout << dist(a, b) << endl;
        }
        else if(flag == 2)
        {
            float a, b;
            cin >> a >> b;
            cout << dist(a, b) << endl;
        }
        else if(flag == 3)
        {
            Complex a, b;
            double a1, a2, b1, b2;
            cin >> a1 >> a2 >> b1 >> b2;
            a.set(a1, a2), b.set(b1, b2);
            cout << dist(a, b) << endl;
        }
    }

    return 0;
}
```
## 7-9 对称排序 你供职于由一群丑星作为台柱子的信天翁马戏团。
你供职于由一群丑星作为台柱子的信天翁马戏团。你刚完成了一个程序编写，它按明星们姓名字符串的长度非降序（即当前姓名的长度至少与前一个姓名长度一样）顺序输出他们的名单。然而，你的老板不喜欢这种输出格式，提议输出的首、尾名字长度较短，而中间部分长度稍长，显得有对称性。老板说的具体办法是对已按长度排好序的名单逐对处理，将前者放于当前序列的首部，后者放在尾部。如输入样例中的第一个案例，Bo和Pat是首对名字，Jean和Kevin是第二对，余此类推。
```
#include<iostream>
#include<cstring>
using namespace std;
 
int main(){
    int n;
    int w=0;
    while(1){
        cin>>n;
        if(n==0) break;
        
        string s[n];
        for(int i=0;i<n;i++) cin>>s[i];
        w++;
        printf("SET %d\n",w);
        for(int i=0;i<n;i++){
            if(i%2==0)
                cout<<s[i]<<endl;
        }
        for(int i=n-1;i>=0;i--){
            if(i%2==1)
                cout<<s[i]<<endl;
        }
    }
}
```
## 7-10 组最大数 (15 分) 设有n个正整数，将他们连接成一排，组成一个最大的多位整数。
设有n个正整数，将他们连接成一排，组成一个最大的多位整数。
如:n=3时，3个整数13,312,343连成的最大整数为34331213。
如:n=4时，4个整数7,13,4,246连接成的最大整数为7424613。
```
#include<iostream>
#include<vector>
#include<string>
using namespace std;

class Solution {
public:
    void sort(vector<string> &str_array) {
        int len = str_array.size();
        for (int i = 0; i < len - 1; i++) {
            for (int j = 0; j < len - 1 - i; j++) {
                if ((str_array[j] + str_array[j + 1]) < (str_array[j+1] + str_array[j]))
                    swap(str_array[j], str_array[j + 1]);
            }
        }
    }
};

int main() {
    int tmp;
    while (cin >> tmp) {
        vector<string> str_array;
        string str;
        for (int i = 0; i < tmp; i++) {
            cin >> str;
            str_array.push_back(str);
        }
        Solution s;
        s.sort(str_array);
        for (int i = 0; i < str_array.size(); i++) {
            cout << str_array[i];
        }
        cout << endl;
    }
    return 0;
}
```









